-- BEGIN Added by all-cabal-hashes-tool
package-hashes:
    MD5:160146cc929168ed5c0a44a3d320f73c
    SHA1:1a794a0114f16ed8a0d3f1e8c0198b9dda1aeb0a
    SHA256:958725f3fac702678a79c6014d3534239499d8aebc2f79d95d2a479cecabdb5b
    SHA512:9126f84b908aae7f8fbc3c7ec13f01ef57a507e885f509c146468cb34f2d14097dd353be3bf78d42d98d74f2398b5a97e9f79266d5ed27253cb80da4fc8146ad
    Skein512_512:9eb589532606dff5a103c1983a5174deb69e0e87e2bc067d0bb219532f3f12861e3215f2a06fa452171eeba7148eab0222a97ad9e2f469f8943a139530eaed93

package-locations:
    https://hackage.haskell.org/package/procrastinating-variable-1.0.1/procrastinating-variable-1.0.1.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/procrastinating-variable-1.0.1.tar.gz

package-size: 3545
-- END Added by all-cabal-hashes-tool

Name:           procrastinating-variable
Synopsis:       Haskell values that cannot be evaluated immediately.
Version:        1.0.1
Category:       Data
Cabal-Version:  >= 1.2
License:        BSD3
License-File:   LICENSE
Author:         Gregory Crosswhite
Maintainer:     Gregory Crosswhite <gcross@phys.washington.edu>
Homepage:       http://github.com/gcross/procrastinating-variable
Build-Type:     Simple
Description:    Procrastinating variables ('PVar's) are meant to be used in cases where
                you want to give someone a value that you do not have available yet,
                but will definitely have ready by the time that they need to use it.
                .
                'PVar's have the advantage that you do not make the user of your value
                execute some kind of unwrapping routine in order to get access to the
                value within.  For example, this is useful when you are constructing
                closures that you want to go ahead and construct now even though some
                of the values that they contain are not available yet.
                .
                'PVar's are implemented with a lazy thunk that reads from
                an 'IORef'; before the 'IORef' is written to, it contains "bottom" (an
                exception with a descriptive error message) so that an error is raised
                in the user code if the variable is accidently accessed before the
                value is ready.
                .
                NOTE: 'PVar's are modeled closely on the 'IVar' implementation in
                the ivar-simple package.  The major difference is that if you
                try to read an 'IVar' before it has been given a value, it blocks
                until the value is available, whereas reading from a 'PVar'
                before it is ready raises an exception.  The reason behind the
                different symantics for 'PVar' is because if the user
                accidently accesses the value too early, you want there to be a
                lot of noise to let him or her know about it, rather than
                merely blocking the thread indefinitely and causing them to
                wonder what went wrong.

Library
  Build-Depends:    base >= 4 && < 5
  Hs-Source-Dirs:   .
  Exposed-Modules:  Data.PVar
  GHC-Options:      -Wall

-- BEGIN Added by all-cabal-hashes-tool
package-hashes:
    MD5:3e6b3072c84084a6b7e23dd7daede6b8
    SHA1:68bf7bd9e3c3e92749ed62a7db68e3ebfdff6c2a
    SHA256:efdba7badb864577828f4bda64fa912ef8f41c4b02616e723d2b79b5ec9878e6
    SHA512:40979a2a431ca9032af97e54a6955eb25dfe16020a0f554f2d1d186097ad2c17f04906d17582c4ce6966f2896695391206bbeb6c82552ce99f9fc8c585e7b5ff
    Skein512_512:9dcabaa260462ebc196be30199a72a154b9a4338c1801d28c1443b71374790febf8ac236e6e2271db4d4f155f95072bd152a735bcf0b8fa2674c88ef8e1609c9

package-locations:
    https://hackage.haskell.org/package/procrastinating-variable-1.0/procrastinating-variable-1.0.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/procrastinating-variable-1.0.tar.gz

package-size: 3541
-- END Added by all-cabal-hashes-tool

Name:           procrastinating-variable
Synopsis:       Haskell values that cannot be evaluated immediately.
Version:        1.0
Category:       Data
Cabal-Version:  >= 1.2
License:        BSD3
License-File:   LICENSE
Author:         Gregory Crosswhite
Maintainer:     Gregory Crosswhite <gcross@phys.washington.edu>
Homepage:       http://github.com/gcross/procrastinating-variable
Build-Type:     Simple
Description:    Procrastinating variables ('PVar's) are meant to be used in cases where
                you want to give someone a value that you do not have available yet,
                but will definitely have ready by the time that they need to use it.
                .
                'PVar's have the advantage that you do not make the user of your value
                execute some kind of unwrapping routine in order to get access to the
                value within.  For example, this is useful when you are constructing
                closures that you want to go ahead and construct now even though some
                of the values that they contain are not available yet.
                .
                'PVar's are implemented with a lazy thunk that reads from
                an 'IORef'; before the 'IORef' is written to, it contains "bottom" (an
                exception with a descriptive error message) so that an error is raised
                in the user code if the variable is accidently accessed before the
                value is ready.
                .
                NOTE: 'PVar's are modeled closely on the 'IVar' implementation in
                the ivar-simple package.  The major difference is that if you
                try to read an 'IVar' before it has been given a value, it blocks
                until the value is available, whereas reading from a 'PVar'
                before it is ready raises an exception.  The reason behind the
                different symantics for 'PVar' is because if the user
                accidently accesses the value too early, you want there to be a
                lot of noise to let him or her know about it, rather than
                merely blocking the thread indefinitely and causing them to
                wonder what went wrong.

Library
  Build-Depends:    base >= 3 && < 5
  Hs-Source-Dirs:   .
  Exposed-Modules:  Data.PVar
  GHC-Options:      -Wall

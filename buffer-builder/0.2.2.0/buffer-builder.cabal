-- BEGIN Added by all-cabal-hashes-tool
package-hashes:
    MD5:eb370dbc9183ac41d43a9e602d024367
    SHA1:5735d6366390849d49a675e7e5e9a35ad843f13b
    SHA256:a5d1b43598052e869f98dcfb9e33b2a9596e6ff76b37103fe23d802c0726638a
    SHA512:896876edda85440bdd6182dddd67fed252b9e1a16840e83eeb9e83d7d157be541ef5ea9d1d495ccdf6b06058359cda0fa70a75a2fe7a897af5ccb202f5ec3e4c
    Skein512_512:771ca894fe426020bdb2adef84d79f0dc4e86484b352819517397d087eb317504083d81dd0045caf3d1c39bff813d4f399c0d3b0215630beaa8c8ca63248dbc6

package-locations:
    https://hackage.haskell.org/package/buffer-builder-0.2.2.0/buffer-builder-0.2.2.0.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/buffer-builder-0.2.2.0.tar.gz

package-size: 21877
-- END Added by all-cabal-hashes-tool

name:                buffer-builder
version:             0.2.2.0
synopsis:            Library for efficiently building up buffers, one piece at a time
description:

    "Data.BufferBuilder" is an efficient library for incrementally building
    up 'ByteString's, one chunk at a time.  Early benchmarks show it
    is over twice as fast as ByteString Builder, primarily because
    'BufferBuilder' is built upon an ST-style restricted monad and
    mutable state instead of ByteString Builder's monoidal AST.
    .
    Internally, BufferBuilder is backed by a few C functions.
    Examination of GHC's output shows nearly optimal code generation
    with no intermediate thunks -- and thus, continuation passing and
    its associated indirect jumps and stack traffic only occur when
    BufferBuilder is asked to append a non-strict ByteString.
    .
    I benchmarked four approaches with a URL encoding benchmark:
    .
      * State monad, concatenating ByteStrings: 6.98 us
    .
      * State monad, ByteString Builder: 2.48 us
    .
      * Crazy explicit RealWorld baton passing with unboxed state: 28.94 us (GHC generated really awful code for this, but see the revision history for the technique)
    .
      * C + FFI + ReaderT: 1.11 us
    .
    Using BufferBuilder is very simple:
    .
    > import qualified Data.BufferBuilder as BB
    > 
    > let byteString = BB.runBufferBuilder $ do
    >       BB.appendBS "http"
    >       BB.appendChar8 '/'
    >       BB.appendBS "//"
    .
    This package also provides "Data.BufferBuilder.Utf8" for generating UTF-8 buffers
    and "Data.BufferBuilder.Json" for encoding data structures into JSON.

license:             BSD3
license-file:        LICENSE
author:              Chad Austin, Andy Friesen
maintainer:          chad@chadaustin.me
copyright:           IMVU Inc., Chad Austin, Andy Friesen
category:            Data
build-type:          Simple
stability:           experimental
homepage:            https://github.com/chadaustin/buffer-builder
cabal-version:       >=1.10
extra-source-files:  test/*.hs changelog.md

library
  exposed-modules:
    Data.BufferBuilder
    Data.BufferBuilder.Utf8
    Data.BufferBuilder.Json

  build-depends: base ==4.*
               , bytestring
               , mtl
               , text
               , vector
               , unordered-containers

  default-language: Haskell2010
  ghc-options: -O2 -Wall
  --ghc-options: -ddump-ds -ddump-simpl -ddump-stg -ddump-opt-cmm -ddump-asm -ddump-to-file

  hs-source-dirs: src
  c-sources: cbits/buffer.cpp cbits/branchlut.cpp
  install-includes: cbits/branchlut.h
  cc-options: -O2 -Wall

test-suite tests
  type: exitcode-stdio-1.0
  main-is: Main.hs
  hs-source-dirs: test
  default-language: Haskell2010
  ghc-options: -O2 -Wall

  build-depends: base ==4.*
               , buffer-builder
               , text
               , tasty
               , tasty-hunit
               , tasty-th
               , tasty-quickcheck
               , HUnit
               , text
               , vector
               , bytestring
               , attoparsec
               , aeson

benchmark bench
  type: exitcode-stdio-1.0
  main-is: Bench.hs
  hs-source-dirs: bench
  default-language: Haskell2010
  ghc-options: -O2 -Wall
  --ghc-options: -ddump-ds -ddump-simpl -ddump-stg -ddump-opt-cmm -ddump-asm -ddump-to-file

  build-depends: base ==4.*
               , bytestring
               , buffer-builder
               , criterion

benchmark json-bench
  type: exitcode-stdio-1.0
  main-is: JsonBench.hs
  hs-source-dirs: bench
  default-language: Haskell2010
  ghc-options: -O2 -Wall
  --ghc-options: -ddump-ds -ddump-simpl -ddump-stg -ddump-opt-cmm -ddump-asm -ddump-to-file
  build-depends: base
               , buffer-builder
               , aeson
               , bytestring
               , text
               , deepseq
               , vector
               , criterion
               , vector
               , json-builder

benchmark url
  type: exitcode-stdio-1.0
  main-is: UrlBench.hs
  hs-source-dirs: bench
  default-language: Haskell2010
  ghc-options: -O2 -Wall
  --ghc-options: -ddump-ds -ddump-simpl -ddump-stg -ddump-opt-cmm -ddump-asm -ddump-to-file
  build-depends: base
               , buffer-builder
               , bytestring
               , http-types
               , text
               , criterion

test-suite tinyjson
  type: exitcode-stdio-1.0
  main-is: TinyJson.hs
  hs-source-dirs: bench
  default-language: Haskell2010
  ghc-options: -O2 -Wall
  --ghc-options: -ddump-ds -ddump-simpl -ddump-stg -ddump-opt-cmm -ddump-asm -ddump-to-file
  build-depends: base
               , buffer-builder
               , aeson
               , bytestring
               , text
               , deepseq
               , criterion

test-suite tinyjson2
  type: exitcode-stdio-1.0
  main-is: TinyJson2.hs
  hs-source-dirs: bench
  default-language: Haskell2010
  ghc-options: -O2 -Wall
  --ghc-options: -ddump-ds -ddump-simpl -ddump-stg -ddump-opt-cmm -ddump-asm -ddump-to-file
  build-depends: base
               , buffer-builder
               , aeson
               , bytestring
               , deepseq
               , criterion
               , vector

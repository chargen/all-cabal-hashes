-- BEGIN Added by all-cabal-hashes-tool
package-hashes:
    MD5:f9efc53378c3feb1ff6bd3ba0bcea48e
    SHA1:338a2acd4068f31017ca3c6976a90540cdbacd67
    SHA256:c15e9aee4c67ccc6e55ecbcc4b32d1a793a3309935e109f8a7fd7d82db806035
    SHA512:fe58a78083d04ec07b09738ab193ea2f528a4d55bedbba59efab4b284b3223706d7ba431419e08a50620e82bb2e26b2429f374c42d58d4227fa3e7a121b24be8
    Skein512_512:87384012da3f70077321ad6a9c85b869f0b5898958ec90f6905901f68ecae5fa5f6ed85686b6c8ac402dfb815919bd05587469b751eb3160fefba1ee7c4de09f

package-locations:
    https://hackage.haskell.org/package/markov-chain-0.0.2/markov-chain-0.0.2.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/markov-chain-0.0.2.tar.gz

package-size: 14905
-- END Added by all-cabal-hashes-tool

Name:             markov-chain
Version:          0.0.2
License:          GPL
License-File:     LICENSE
Author:           Henning Thielemann <haskell@henning-thielemann.de>
Maintainer:       Henning Thielemann <haskell@henning-thielemann.de>
Homepage:         http://darcs.haskell.org/markov-chain/
Category:         Algorithms
Build-Type:       Simple
Build-Depends:    base>=1.0, mtl
-- From the Monad Template Library we only need the State monad.
-- If your compiler does not support functional dependencies,
-- it would be easy to replace that by mapAccumL
-- or by the MTL-split package which is on the way.
Synopsis:         Markov Chains for generating random sequences with a user definable behaviour.
Description:
   This library can be used to generate random sequences of anything
   with a behaviour that is adapted to some training data.
   Input a marketing text or a speech and
   recompose it to another arbitrary text of this sort.
   Input a dictionary of person names and create new names.
   Input a sequence of notes and get out a new melody.
   Input a set of Haskell modules and generate ...
   nice idea but the result will certainly have neither correct syntax nor types.
   I think, it's a good thing about Haskell, that you cannot fool it so easily.
   The idea is very simple:
   The algorithm analyses your input\/training data
   with respect to how likely an @a@ or @e@ follows the letters @r@ and @e@.
   Then on recomposition it chooses subsequent letters randomly
   according to the frequencies found in the training data.
   This library is well suited for /bull-shit generators/.
Tested-With:      GHC==6.4.1
Cabal-Version: >=1.2

Flag splitBase
  description: Choose the new smaller, split-up base package.

Library
  If flag(splitBase)
    Build-Depends: base >= 2, random >= 1.0, mtl, containers
  Else
    Build-Depends: base >=1.0 && < 2, mtl

  GHC-Options:      -Wall
  Hs-Source-Dirs:   src

  Exposed-Modules:
    Data.MarkovChain

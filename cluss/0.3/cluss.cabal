-- BEGIN Added by all-cabal-hashes-tool
x-package-hashes:
    MD5:38fa4a4fb8a72b4b1c0fb4e1129aa008
    SHA1:e14e8513e30f581e83de1c26c1ef6ac26a87eb5a
    SHA256:effd03b754a93b2b3e973e83fb47e961e5a7bfb67002f92d67dff28f9ca8b3e0
    SHA512:db507fdc17e4807f02e979e1e240496e1c8e3ef706d785a6b052cdd6675880613ed90856578cf0776a3978e4fdb153c474abce9e7b9cdef681409ad8040a9b9b
    Skein512_512:ddd05b077bd599993d47ba2a5f909b1f1cc9e7e99db0a84080f6789561bc624f3083a9745242c6635f5c06da35498e13922dd909304e18c4e377977e1bf055fe

x-package-locations:
    https://hackage.haskell.org/package/cluss-0.3/cluss-0.3.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/cluss-0.3.tar.gz

x-package-size: 11301
-- END Added by all-cabal-hashes-tool

name: cluss
category: type system, constraints
version: 0.3
license: BSD3
license-file: LICENSE
cabal-version: >= 1.10
tested-with: GHC==7.8.3
author: Yusuke Matsushita
maintainer: Yusuke Matsushita <y.skm24t@gmail.com>
stability: provisional
homepage: https://github.com/Kinokkory/cluss
bug-reports: https://github.com/Kinokkory/cluss/issues
copyright: (c) Yusuke Matsushita 2014
synopsis: simple alternative to type classes
description:
    A /cluss/ enables you to achieve function overloading, or ad-hoc polymorphism,
    without creating a new type class.
    .
    In order to give ad-hoc polymorphism to a type variable @a@,
    you simply use @'In'@ with a list of \"type patterns\" like @In [Type T, ...] a@,
    which indicates that the type matches some of the patterns;
    which is analogous to a type class indicating that a type matches some of its \"instances\".
    The constraint @In [Type T, ...] a@ is what we call a \"cluss\".
    .
    Clusses can easily be used in a nested way
    and even be /recursive/;
    therefore, they are expressive enough to imitate Haskell-98-style type classes.
    .
    Clusses, however, go beyond a mere alternative to type classes.
    They have /closed/ and /prioritized/ instances and /open/ methods,
    while type classes have open and unprioritized instances and closed methods.
    Those properties give clusses the advantages different from type classes:
    .
        * You can judge whether a type @a@ belongs to a cluss @'In' as@,
        on some level, writing @Has as a@,
        since cluss instances are closed.
    .
        * You can make cluss instances more flexibly,
        without causing overlapping instances or incoherent instances,
        since cluss instances are prioritized.
    .
        * You can create new methods for clusses anywhere in any module,
        since cluss methods are open.
    .
    More information can be found in the <http://hackage.haskell.org/package/cluss hackage's haddock> or the <http://kinokkory.github.io/cluss/ updated haddock>.

build-type: Simple

source-repository head
    type: git
    location: git@github.com:Kinokkory/cluss.git

library
    hs-source-dirs: src
    default-language: Haskell2010
    other-extensions:
        Trustworthy,
        ScopedTypeVariables, TypeOperators,
        RankNTypes, TypeFamilies,
        DataKinds, ConstraintKinds, PolyKinds,
        MultiParamTypeClasses, FlexibleInstances, UndecidableInstances, FlexibleContexts
    build-depends:
        base ==4.*,
        template-haskell >=2.5
    exposed-modules: Type.Cluss, Type.Cluss.TH
    ghc-options: -Wall

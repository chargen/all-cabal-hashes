-- BEGIN Added by all-cabal-hashes-tool
package-hashes:
    MD5:659e3d2910d215d9e95d2d28404001ee
    SHA1:3699c5a24cda7d22075371affb8d11d278a04e15
    SHA256:b7b119eb12ef2e01f8dff2255f5eb5cbdc8fa76b62a3ad03fea97a7c606f76e8
    SHA512:00cf11d0f16eaf4b06ab83c8c22563b20749a2522fbc9bd84afcc931e3fd4d6fd6eaef38a8e8f2089f22ea96d0b6b93d8f7369a8d2764d87fb57151b1713ed83
    Skein512_512:6f9308bb200b23d36a7977d3bb139d4dd8944fa070a724f92a5c501fbef1baab45e2ba61b74936d6e9c7f04c9f5c671b5c48b0f99d6aad9fa8d66daa8af3794f

package-locations:
    https://hackage.haskell.org/package/cluss-0.2/cluss-0.2.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/cluss-0.2.tar.gz

package-size: 10894
-- END Added by all-cabal-hashes-tool

name: cluss
category: type system, constraints
version: 0.2
x-revision: 4
license: BSD3
license-file: LICENSE
cabal-version: >= 1.10
tested-with: GHC==7.8.3
author: Yusuke Matsushita
maintainer: Yusuke Matsushita <y.skm24t@gmail.com>
stability: provisional
homepage: https://github.com/Kinokkory/cluss
bug-reports: https://github.com/Kinokkory/cluss/issues
copyright: (c) Yusuke Matsushita 2014
synopsis: simple alternative to type classes
description:
    A /cluss/ enables you to achieve function overloading, or ad-hoc polymorphism,
    without creating a new type class.
    .
    In order to give ad-hoc polymorphism to a type variable @a@,
    you simply use @'In'@ with a list of \"type patterns\" like @In [Type T, ...] a@,
    which indicates that the type matches some of the patterns;
    which is analogous to a type class indicating that a type matches some of its \"instances\".
    The constraint @In [Type T, ...] a@ is what we call a \"cluss\".
    .
    Clusses can easily be used in a nested way
    and even be /recursive/;
    therefore, they are expressive enough to imitate Haskell-98-style type classes.
    .
    Clusses, however, go beyond a mere alternative to type classes.
    They have /closed/ and /prioritized/ instances and /open/ methods,
    while type classes have open and unprioritized instances and closed methods.
    Those properties give clusses the advantages different from type classes:
    .
        * You can judge whether a type @a@ belongs to a cluss @'In' as@,
        on some level, writing @Has as a@,
        since cluss instances are closed.
    .
        * You can make cluss instances more flexibly,
        without causing overlapping instances or incoherent instances,
        since cluss instances are prioritized.
    .
        * You can create new methods for clusses anywhere in any module,
        since cluss methods are open.
    .
    More information can be found in the <http://hackage.haskell.org/package/cluss hackage's haddock> or the <http://kinokkory.github.io/cluss/ updated haddock>.

build-type: Simple

source-repository head
    type: git
    location: git@github.com:Kinokkory/cluss.git

library
    hs-source-dirs: src
    default-language: Haskell2010
    other-extensions:
        Trustworthy,
        ScopedTypeVariables, TypeOperators,
        RankNTypes, TypeFamilies,
        DataKinds, ConstraintKinds, PolyKinds,
        MultiParamTypeClasses, FlexibleInstances, UndecidableInstances, FlexibleContexts
    build-depends:
        base ==4.*,
        template-haskell >=2.5
    exposed-modules: Type.Cluss, Type.Cluss.TH
    ghc-options: -Wall

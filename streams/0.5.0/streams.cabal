name:          streams
category:      Control, Comonads
version:       0.5.0
license:       BSD3
cabal-version: >= 1.6
license-file:  LICENSE
author:        Edward A. Kmett
maintainer:    Edward A. Kmett <ekmett@gmail.com>
stability:     provisional
homepage:      http://github.com/ekmett/streams
copyright:     Copyright 2011 Edward Kmett
               Copyright 2010 Tony Morris, Oliver Taylor, Eelis van der Weegen
               Copyright 2007-2010 Wouter Swierstra, Bas van Dijk
synopsis:      Various Haskell 2010 stream comonads
build-type:    Simple
extra-source-files: README
description:   
  Various Haskell 2010 stream comonads.
  .
  * "Data.Stream.Branching" provides an \"f-Branching Stream\" comonad, aka the cofree comonad, or generalized rose tree. 
  .
  > data Stream f a = a :< f (Stream a)
  .
  * "Data.Stream.Future" provides a coinductive anti-causal stream, or non-empty 'ZipList'. The comonad provides access to only the 
    tail of the stream. Like a conventional 'ZipList', this is /not/ a monad.
  .
  > data Future a = Last a | a :< Future a
  .
  * "Data.Stream.Future.Skew" provides a non-empty skew-binary random-access-list with the semantics of @Data.Stream.Future@. As with
    "Data.Stream.Future" this stream is not a 'Monad', since the 'Applicative' instance zips streams of potentially differing lengths. 
    The random-access-list structure provides a number of operations logarithmic access time, but makes 'Data.Stream.Future.Skew.cons' 
    less productive. Where applicable "Data.Stream.Infinite.Skew" may be more efficient, due to a lazier and more efficient 'Applicative' 
    instance.
  . 
  >
  .
  * "Data.Stream.NonEmpty" provides a non-empty list comonad where the Applicative and Monad work like those of the @[a]@. 
    Being non-empty, it trades in the 'Alternative' and 'Monoid' instances of @[a]@ for weaker append-based 'FunctorAlt' and 'Semigroup'
    instances while becoming a member of 'Comonad' and 'ComonadApply'. Acting like a list, the semantics of '<*>' and
    '<.>' take a cross-product of membership from both 'NonEmpty' lists rather than zipping like a 'Future'
  .
  > data NonEmpty a = a :| [a]
  .
  * "Data.Stream.Infinite" provides a coinductive infinite anti-causal stream. The 'Comonad' provides access to the tail of the
    stream and the 'Applicative' zips streams together. Unlike 'Future', infinite stream form a 'Monad'. The monad diagonalizes 
    the 'Stream', which is consistent with the behavior of the 'Applicative', and the view of a 'Stream' as a isomorphic to the reader 
    monad from the natural numbers. Being infinite in length, there is no 'Alternative' instance, but instead the 'FunctorAlt'
    instance provides access to the 'Semigroup' of interleaving streams.
  .
  > data Stream a = a :< Stream a
  .
  * "Data.Stream.Infinite.Skew" provides an infinite skew-binary random-access-list with the semantics of "Data.Stream.Infinite"
    Since every stream is infinite, the 'Applicative' instance can be considerably less strict than the corresponding instance for 
    "Data.Stream.Future.Skew" and performs asymptotically better.
  .
  >
  .
  * "Data.Stream.Infinite.Functional.Zipper" provides a bi-infinite sequence, represented as a pure function with an accumulating
    parameter added to optimize moving the current focus.
  .
  > data Zipper a = !Integer :~ (Integer -> a)
  .
  /Changes since 0.1/: 
  .
  * A number of strictness issues with 'NonEmpty' were fixed
  .
  * More documentation

source-repository head
  type: git
  location: git://github.com/ekmett/streams.git
  

library
  build-depends:
    base >= 4 && < 4.4,
    comonad >= 0.9 && < 0.10,
    functor-apply >= 0.10 && < 0.11,
    distributive >= 0.1 && < 0.2,
    semigroups >= 0.3.4 && < 0.4

  extensions: CPP
  if impl(ghc)
    cpp-options: -DLANGUAGE_DeriveDataTypeable
    extensions: FlexibleContexts, DeriveDataTypeable

  exposed-modules:
    Data.Stream.Branching
    Data.Stream.Future
    Data.Stream.Future.Skew
    Data.Stream.NonEmpty
    Data.Stream.Infinite
    Data.Stream.Infinite.Skew
    Data.Stream.Infinite.Functional.Zipper

  ghc-options: -Wall



package-hashes:
    MD5:c9d5b7f7f7028eaa46ca0213e51ff455
    SHA1:b1478c5386c9270c82ee208b9c3a1bb551acc86c
    SHA256:a00c7ae71e57d2a210fe570f476a073c1cac2db178bef2c9f25801d1be6d2326
    SHA512:6719feac784ca7077988b39d18e1d766ebbc650da4018455de9ca98fbf20d7256a072f93bd8cddb4bd4aee7cf492278c5bb2e459778a12a970ab72a05e29ac47
    Skein512_512:4594866d8efb593a2ccb0efc38641a6a8669da4a36abe68ff50ea93ae739df7f58eee3d0798e1557f9cd5c6f5c68ea0127d0b5bd5e1cd8c8fa54a99dde4121c4

package-locations:
    https://hackage.haskell.org/package/streams-0.5.0/streams-0.5.0.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/streams-0.5.0.tar.gz

package-size: 19109

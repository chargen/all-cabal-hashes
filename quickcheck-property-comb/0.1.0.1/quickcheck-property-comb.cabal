-- BEGIN Added by all-cabal-hashes-tool
x-package-hashes:
    MD5:71e5151190cd8f4474c4e15c417c5bb9
    SHA1:d9a0b2b5577db5f70a810fcb91dad95696cd024f
    SHA256:10f63539d9e3335994fc86c6beb7e51d25c02c7ef953e5ccc0c44a0a3e7c501d
    SHA512:01e8d5917a57b6a58db25f696199a2cbf1d7464c2d1a48ba2593989267557588c94dbf3276d423752d69f6cd8b2eb1fc15a32e6d4482603ac344d4298d2d0d78
    Skein512_512:ed0f59faca2c0a42f304d9abe99fd19150cb07c0f746d4255254748933be020135c6bfbc35a316d032eafe19a8405525bc1d831282f61d7199d60bf1f9b4b27b

x-package-locations:
    https://hackage.haskell.org/package/quickcheck-property-comb-0.1.0.1/quickcheck-property-comb-0.1.0.1.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/quickcheck-property-comb-0.1.0.1.tar.gz

x-package-size: 2823
-- END Added by all-cabal-hashes-tool

-- Initial quickcheck-property-comb.cabal generated by cabal init.  For 
-- further documentation, see http://haskell.org/cabal/users-guide/

name:                quickcheck-property-comb
version:             0.1.0.1
synopsis:            Combinators for Quickcheck Property construction and diagnostics
description:         
  These are simple monads that aim to reduce the pain of composing
  invariants/properties, and the documenting of those
  invariants for determining the cause of failure.
  Specifically, they provide a tool for effective diagnostic
  for invariants with changing post-conditions, leading to a
  faster cause-of-failure diagnosis.
  .
  Example case for invariants on a data structure "Consumers".
  .
  > data (Ord l) => Consumers l =
  >   Consumers {
  >     introduced :: S.Set l,
  >     met :: M.Map (S.Set l) Bool,
  >     disjoints :: Disjoints l
  >   }
  >
  > introduced_in_disjoint :: Inv (Consumers l)
  > introduced_in_disjoint = do
  >   doc "all at quantity are a singleton subset in disjoints"
  >   subsets       <- (map S.singleton) . S.toList . introduced <$> cause
  >   disjoint_sets <- disjoints <$> cause
  >   return . and . map ((flip S.member) disjoint_sets) $ subsets
  > 
  > disjoint_sizes ::  Inv (Disjoints l)
  > disjoint_sizes = do
  >  doc . unlines $
  >    [ "the intersection of introduced and disjoints are the only allowed",
  >     "singleton sets in disjoints"
  >      ]
  >  disjoints' <- cause 
  >  -- Do the checking
  >  return False
  >
  > disjoints_eq :: Inv (Disjoints l)
  > disjoints_eq = do
  >   doc "disjoint sets are equal in size"
  >   -- ..
  >   return True
  >
  > disjoints_inv :: Invariants (Disjoints l)
  > disjoints_inv= do
  >   sat disjoints_eq
  >   sat disjoints_sizes
  > 
  > inv_consumers :: Invariants (Consumers l)
  > inv_consumers = do
  >   satcomp disjoints disjoints_inv
  >   satcomp met met_inv
  >   sat introduced_in_disjoint
  . 
  And to run the Consumer invariant on generated cases: 
  .
  > prop_testedFunction :: Arg -> Property
  > prop_testedFunction arg = 
  >  let consumers = testedFunction arg in
  >    runInvariants consumers inv_consumers

homepage:            http://www.github.com/jfeltz/quickcheck-property-comb
license:             PublicDomain
license-file:        LICENSE
author:              John Feltz
maintainer:          jfeltz@gmail.com
category:            Testing
build-type:          Simple
cabal-version:       >=1.10

library
  exposed-modules:     Test.QuickCheck.Property.Comb
  -- other-modules:       
  other-extensions:    TupleSections, ScopedTypeVariables, GeneralizedNewtypeDeriving
  build-depends:       base >=4.5 && <4.6, QuickCheck >=2.5 && <=2.6, mtl >=2.1 && <2.2
  hs-source-dirs:      ./ 
  default-language:    Haskell2010

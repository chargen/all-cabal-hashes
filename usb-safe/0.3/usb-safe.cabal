-- BEGIN Added by all-cabal-hashes-tool
x-package-hashes:
    MD5:1ee776b76ed0c52dfdc20cf0ba86a044
    SHA1:b166235a17fe9d3929b57b4dc3660165c3aa254d
    SHA256:82d43583ee361c0667ca10dda9c36380d8d1ba1539dae8d8620a94e04657dbb1
    SHA512:a33c659d9dbf44ac3f4df1098f2863dd0fa26fa68162bc7e62deeab9f4175d725b50dcd80cecaef2239dd60d01c3abc85c856b016fa4e1b130906a260f59a2ca
    Skein512_512:72e7d6446a1dcaebf55201872f708e3ae033c73a3b6e7df295f928253ade3630698d5aaa215741e0fa03aa849b699efc75e0166d0ee7e1cff435654266fe4cd7

x-package-locations:
    https://hackage.haskell.org/package/usb-safe-0.3/usb-safe-0.3.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/usb-safe-0.3.tar.gz

x-package-size: 14649
-- END Added by all-cabal-hashes-tool

name:          usb-safe
version:       0.3
cabal-version: >=1.6
build-type:    Simple
license:       BSD3
license-file:  LICENSE
copyright:     2009 Bas van Dijk
author:        Bas van Dijk
maintainer:    Bas van Dijk <v.dijk.bas@gmail.com>
stability:     experimental
category:      System
synopsis:      Wrapper around the usb package adding extra type-safety
description:
  The usb library provides a standard Haskell abstracting layer over
  bindings-libusb providing: abstract types instead of Ptrs, automatic
  marshalling and unmarshalling, automatic garbage collection,
  exceptions instead of integer return codes, etc..

  .

  While all that is very nice there are still some things that you can
  do wrong. For example doing I/O with a closed device or reading from
  or writing to an endpoint which doesn't belong to the claimed
  interface. Or reading from an Out endpoint or writing to an In
  endpoint.

  .

  usb-safe provides the following guarantees:

  .

  * You can't reference handles to devices that are closed. In other words: no
     I/O with closed handles is possible.

  .

  * The programmer specifies the region in which devices should remain open. On
    exit from the region the opened devices are automatically closed.

  .

  * You can't reference handles to configurations that have not been set.

  .

  * You can't reference handles to interfaces that have not been claimed.

  .

  * You can't reference handles to alternates that have not been set.

  .

  * You can't reference endpoints that don't belong to a setted alternate.

  .

  * You can't read from an endpoint with an Out transfer direction.

  .

  * You can't write to an endpoint with an In transfer direction.

  .

  * You can't read from or write to endpoints with the unsupported transfer
    types Control and Isochronous. Only I/O with endpoints with the Bulk and
    Interrupt transfer types is allowed.

  .

  The primary technique used in usb-safe is called \"Lightweight monadic
  regions\" which was invented by Oleg Kiselyov and Chung-chieh Shan.
  See:

  .

  <http://okmij.org/ftp/Haskell/regions.html#light-weight>

source-repository head
  Type:     darcs
  Location: http://code.haskell.org/~basvandijk/code/usb-safe

Library
  GHC-Options: -O2 -Wall
  build-depends: base                      >= 4 && < 4.2
               , usb                       == 0.3.*
               , bytestring                == 0.9.*
               , unicode-symbols           == 0.1.*
               , transformers              >= 0.1.4 && < 0.2
               , MonadCatchIO-transformers == 0.0.2.*
               , monads-fd                 == 0.0.*
  exposed-modules: System.USB.Safe


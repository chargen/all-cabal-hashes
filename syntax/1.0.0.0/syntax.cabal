name:                syntax
version:             1.0.0.0
x-revision: 1
synopsis:            Reversible parsing and pretty-printing.
description:
  UPDATE: I have a lot of work now and so I haven't updated the library in a while. However once I get some free time I will probably rewrite it with a new, cleaner design (focused more on adjoints then isomorphisms). Consider this package very experimental :)
  .
  "syntax" allows you to write a single syntax description and instantiate is both as a parser and a pretty printer.
  .
  Syntax descriptions are written in applicative or arrow style. The library uses a custom typeclass hierarchy, provided
  by the "semi-iso" package. Most of the time you will be using operators like '/$/', '/*/' and '/+/' (= '<|>'), just
  like parser combinators. When more power is needed - e.g. when the syntax depends on the parsed or printed value -
  you turn to arrows.
  .
  Semi-isomorphisms from "semi-iso" are the basic building block of syntax descriptions. I recommend reading
  the hackage page of "semi-iso" first, as it contains much more information.
  .
  Once you write a syntax description (polymorphic in the syntax category) you can instantiate it both as a parser or as
  a pretty-printer. The library "syntax-attoparsec" gives you the ability to extract an Attoparsec parser. Pretty-printing
  is implemented by the "syntax-printer" library, which uses Text and ByteString builders. (Note that formatting is handled
  by "syntax" itself, not by the printer library)
  .
  Advanced formatting and parsing (for example indentation, haskell layout rule) is implemented as category transformers
  (similar to monad transformers). Currently only simple indentation is implemented (in "Data.Syntax.Indent") - basically
  a reader category transformer that tracks current indentation level. I plan on implementing Haskell layout rule in the
  future.
  .
  The library can work with both text and binary data. Alas, there are no binary combinators implemented yet.
  .
  EXAMPLES! See @syntax-example@ and @syntax-example-json@ for examples.
  .
  * "syntax-example" implements a simple lambda calculus.
  .
  * "syntax-example-json" implements a json parser and pretty printer.
license:             MIT
license-file:        LICENSE
author:              Paweł Nowak
maintainer:          Paweł Nowak <pawel834@gmail.com>
copyright:           Paweł Nowak 2014
category:            Data
build-type:          Simple
cabal-version:       >=1.10

source-repository head
  type:     git
  location: git@github.com:Pawel834/syntax.git

library
  exposed-modules:     Data.Syntax
                       Data.Syntax.Char
                       Data.Syntax.Combinator
                       Data.Syntax.Indent
  build-depends:       base >= 4 && < 5, mono-traversable, lens >= 4, semi-iso >= 1, scientific >= 0.3, text, vector
  default-language:    Haskell2010


package-hashes:
    MD5:359679b78f755d6dc9a1e57e46fbe234
    SHA1:a005d5d19f7b7047bfdd863ad76a01561fc1ff22
    SHA256:fd548debb4f442bc23f24389c0d2d89f72fbe5fed061a62c94eed21fdcfa0bb6
    SHA512:95a6f6a9030a3addf356d99c8d929d2472b5935b10badb09d834e4a5ee6977ce4338773454549b2978fee7e5d0837f81c60b2f871f1b9080a4df371165478f28
    Skein512_512:902015a8bef996b83b2ef47f8ca8062bbc014aab45da94ab7a9c94a65b2e5c50ec8fbc0c6fc8c2dcd32f7198907f75dc682c556371f629679dd0ad797bdc9a0d

package-locations:
    https://hackage.haskell.org/package/syntax-1.0.0.0/syntax-1.0.0.0.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/syntax-1.0.0.0.tar.gz

package-size: 6820

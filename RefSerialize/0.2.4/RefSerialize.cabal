-- BEGIN Added by all-cabal-hashes-tool
x-package-hashes:
    MD5:ebcc72ef86b462eb786c415b2ac88518
    SHA1:a776f8d047742d2e26f93963410f824a0456cc4d
    SHA256:520949b01a18f514b897d82cfc4056f21d97b84feef6aac63230237aa883f452
    SHA512:d99e02499f864c7d46bf78dc1a303342a0b8803268443a5083c9cc62af33bfe84e4390c14a2cf53f9c1420e8be8f5b16e74e0ef4a6e68b384f20527d33e079dd
    Skein512_512:d4238cbaa2aa3a6307cb8c5ec828f70d160bc1eb506ff641abd67d1afbd076e081a4a8de4762cd0b42d691b7a670155e978f3b2f39e91b707b85514309752861

x-package-locations:
    https://hackage.haskell.org/package/RefSerialize-0.2.4/RefSerialize-0.2.4.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/RefSerialize-0.2.4.tar.gz

x-package-size: 36121
-- END Added by all-cabal-hashes-tool

name:                RefSerialize
version:             0.2.4
synopsis:            Write to and read from Strings maintaining internal memory references
description:
                     Read, Show and Data.Binary do not check for repeated references to the same address.
                     As a result, the data is duplicated when serialized. This is a waste of space in the filesystem
                     and  also a waste of serialization time. but the worst consequence is that, when the serialized data is read,
                     it allocates multiple copies for the same object when referenced multiple times. Because multiple referenced
                     data is very typical in a pure language such is Haskell, this means that the resulting data loose the beatiful
                     economy of space and processing time that referential transparency permits.
                     .
                     Every instance of Show/Read is also a instance of Data.RefSerialize.
                     .
                     This package allows the serialization and deserialization of large data structures without duplication of data, with
                     the result of optimized performance and memory usage. It is also useful for debugging purposes.
                     .
                     There are automatic derived instances for instances of Read/Show. Lists of non-chars have its own instance.
                     The deserializer contains a subset of Parsec.Token for defining deserializing parsers.
                     .
                     the serialized string has the form:
                     .
                     @expr( var1, ...varn) where  var1=value1,..valn=valueN @
                     .
                     so that the string can be EVALuated.
                     .
                     See demo.hs and tutorial.
                     .
                     in this release:
                            .
                            *  Proper trailing withespace handlling for instances of Read
                            .
                            *  Error handllig for instances of Read.
                     .
                     To do:
                     .
                                 -derived instances for Data.Binary
                     .
                                 -serialization to/from ByteStings
                     

category:           Parsing, Data, Database
license:             BSD3
license-file:        LICENSE
author:              Alberto GÃ³mez Corona
maintainer:          agocorona@gmail.com
Tested-With:         GHC == 6.8.2
Build-Type:          Simple
build-Depends:       base >=3 && <4,containers
Cabal-Version:       >= 1.2

exposed-modules:     Data.RefSerialize, Data.Parser, Data.Serialize
ghc-options:    -O2

name:                runmemo
version:             1.0.0.1
synopsis:            A simple memoization helper library

description:
  This library encourages you to do memoization
  in three separate steps:
  .
  (1) Create a memoizable function
  .
  (2) Create or select an appropriate memoizer
  .
  (3) Run the memoizer on the memoizable function
  .
  Let's start with the first.
  When you create a memoizable function,
  you should use the @self@ convention,
  which is that the first input to the function is @self@,
  and all recursive calls are replaced with @self@.
  One common convention that goes well with the @self@ convention
  is using a helper function @go@, like so:
  .
  @
  fib :: Memoizable (Integer -> Integer)
  fib self = go
  \  where go 0 = 1
  \        go 1 = 1
  \        go n = self (n-1) + self (n-2)
  @
  .
  Now for the second. For this example,
  we need a Memoizer that can handle an @Integer@ input,
  and an @Integer@ output. @Data.MemoCombinators@ provides
  @integral@, which handles any @Integral@ input, and
  any output. @Data.MemoUgly@ provides @memo@,
  which can memoize any function @a -> b@, given an @Ord@ instance
  for @a@.
  .
  Third, let's run our memoizers!
  Since we have decoupled the definition of the memoized function
  from its actual memoization, we can create multiple
  memoized versions of the same function if we so desire.
  .
  @
  import qualified Data.MemoUgly as Ugly
  import qualified Data.MemoCombinators as MC
  .
  fibUgly :: Integer -> Integer
  fibUgly = runMemo Ugly.memo fib
  .
  fibMC :: Integer -> Integer
  fibMC = runMemo MC.integral fib
  @
  .
  You could easily do the same with @Data.MemoTrie.memo@,
  @Data.Function.Memoize.memoize@, etc.
  .
  Using this technique, you can create local memoized functions
  whose memo tables are garbage collected as soon as
  they are no longer needed.


homepage:            https://github.com/DanBurton/runmemo
license:             BSD3
license-file:        LICENSE
author:              Dan Burton
maintainer:          danburton.email@gmail.com
copyright:           (c) Dan Burton 2012

category:            Data
build-type:          Simple
cabal-version:       >=1.8

library
  hs-source-dirs:    src
  exposed-modules:   Data.RunMemo
  extensions:        NoImplicitPrelude
  ghc-options:       -Wall

test-suite test-race
  type:            exitcode-stdio-1.0
  hs-source-dirs:  test, src
  main-is:         test-race.hs
  build-depends:   data-memocombinators >= 0.4, base == 4.*, time >= 1.4

source-repository head
  type:     git
  location: git@github.com:DanBurton/runmemo.git

source-repository this
  type:     git
  location: git@github.com:DanBurton/runmemo.git
  tag:      runmemo-1.0.0.1


package-hashes:
    MD5:b89daaa101c5ba45fed406b03267d950
    SHA1:1f9232d51d58a9e34b5af833c20283133efac52f
    SHA256:ba5ef3177f8fe5f443808e44f62d03b23ac19bbef7f708e40532031a3505d689
    SHA512:c39d08fa4336462560e56cd506d0fbf16de506c77bbe4264669f579a9d624a80a9927f7e3e4d45f9da1bdfb924a999c85f9e360bf6220eb28133bbeb76034109
    Skein512_512:47ce2dcbb6275e5246ee0c4a30f1c28a5a837a5be015620a09c3bfe4460d5699b4773ffb2cb88a300dcf30392e2779d48b35862befc74956ae602aa972fd3608

package-locations:
    https://hackage.haskell.org/package/runmemo-1.0.0.1/runmemo-1.0.0.1.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/runmemo-1.0.0.1.tar.gz


-- BEGIN Added by all-cabal-hashes-tool
x-package-hashes:
    MD5:96735d1a37c6ccad3d65883d3a32e1ce
    SHA1:0f93e6632488b13d8ec3dab7cf3bc71585de7095
    SHA256:ce3c0e46099da78f323e8e008d379bb9fa02b21f39c23cde5403ec17b48b5bd9
    SHA512:c1c92acd01186547a56991e5ed1175eeff8d96ac5555c916561af4e390a9337a8f8d4715d0aca98ab3037d6e4dda242122a98ca77a289271542c5e7ac3e37fd4
    Skein512_512:7aef3e9db6f3dcaf9d18b2c95ea65c2800a8d97a6d05741988457be0ee83767b10c9079bad6bbbac6f6b371b2c2a6c1b5ffd6e0a6169a63f9eb9f45131cd8838

x-package-locations:
    https://hackage.haskell.org/package/Grow-1.1.0.2/Grow-1.1.0.2.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/Grow-1.1.0.2.tar.gz

x-package-size: 5131
-- END Added by all-cabal-hashes-tool

-- content information
name:          Grow
category:      Build
synopsis:      A declarative make-like interpreter.
description:   Grow is a well-defined replacement for Makefiles and the like to build complex
               hierarchies of files with minimal effort. 
               .
               Like many Makefile-like tools, Grow depends on the notion of
               timestamps to determine whether a file should be recompiled or
               not. Grow is much simpler than those, though, and I might argue way
               easier to use as well.
               .
               On startup, Grow will look for a file named "Seed" in the current
               directory, and evaluate the grow expressions contained within.
               .
               For example, here is a simple Seed file to compile a single C file
               into an executable.
               .
               > tee $$arg:in {
               >   all = ($main:seq "All done !"):in $execs
               >   execs = hook ld [main] [main.o] :in $objects
               >   objects = hook cc [main.o] [main.c]
               > }
               .
               Notice the `hook` function ? It is the Grow primitive that calls an
               external program to perform actual tasks. 
               .
               In Grow, hooks are expected to only accept files as their arguments,
               so we have to write the wrapper scripts `cc` and `ld` that accept
               arguments in the form "<destination>... <source>...". They are pretty
               trivial to write since they only involve renaming variables and
               swapping arguments.
               .
               Here are sample `cc` and `ld` scripts to show you there is nothing
               magical about them :
               .
               > #!/bin/bash
               > obj="$1" ; shift ; src="$1"
               > gcc -c "$src" -o "$obj"
               .
               > #!/bin/bash
               > bin="$1" ; shift ; obj="$1"
               > gcc "$obj" -o "$bin"
               .
               In grow, instead of writing recipes in the configuration, we just declare
               hooks and then write the appropriate wrapper scripts to call compilers with
               the correct flags and arguments.

-- meta-information
author:        Marc Coiffier
maintainer:    marc.coiffier@gmail.com
version:       1.1.0.2
license:       OtherLicense
license-file:  LICENSE

-- build information
build-type:    Simple
cabal-version: >=1.10

library
  exposed-modules: Grow Language.Grow Language.Syntax.Grow
  build-depends: base (== 4.6.*), definitive-base (== 1.2.*), containers (== 0.5.*), deepseq (== 1.3.*), array (== 0.5.*), bytestring (== 0.10.*), vector (== 0.10.*), primitive (== 0.5.*), definitive-parser (== 1.2.*), definitive-filesystem (== 1.2.*), definitive-reactive (== 1.0.*), clock (== 0.4.*), directory (== 1.2.*), filepath (== 1.3.*), time (== 1.4.*), old-locale (== 1.0.*), unix (== 2.7.*), process (== 1.2.*)
  default-extensions: RebindableSyntax NoMonomorphismRestriction GeneralizedNewtypeDeriving FlexibleInstances LambdaCase FlexibleContexts MultiParamTypeClasses ImplicitParams
  ghc-options: 
  default-language: Haskell2010

-- BEGIN Added by all-cabal-hashes-tool
package-hashes:
    MD5:cc27755ba84d5563d91129d55423630f
    SHA1:25b0769448339cdce8ec9452251cda900095dd00
    SHA256:1949e415c7f97241960d2c792b42db17c71ddc3fc5a9b5f48f402ea3259e169c
    SHA512:694d525c970c806102d9b41094fa5081604cc15bc62632cb3113858fcf4dee3057f114935fb604996fe6a348508066988e48aeaf19764e6f1cbfb8a1b8bc3db0
    Skein512_512:c839da3280ec625083dcf54ed207a1d8efd2ef618747b5154348179be7883c52f198c1732f51fe9a398bbc275a86c9c0b5f3037721b68b1714fa55c34fbb5466

package-locations:
    https://hackage.haskell.org/package/strict-base-types-0.2.3/strict-base-types-0.2.3.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/strict-base-types-0.2.3.tar.gz

package-size: 7500
-- END Added by all-cabal-hashes-tool

Name:           strict-base-types
Version:        0.2.3
Synopsis:       Strict variants of the types provided in base.
Category:       Data
Description:
     It is common knowledge that lazy datastructures can lead to space-leaks.
     This problem is particularly prominent, when using lazy datastructures to
     store the state of a long-running application in memory. The easiest
     solution to this problem is to use fully strict types to store such state
     values. By \"fully strict types\" we mean types for whose values it holds
     that, if they are in weak-head normal form, then they are also in normal
     form. Intuitively, this means that values of fully strict types cannot
     contain unevaluated thunks.
     .
     To define a fully strict datatype, one typically uses the following recipe.
     .
     1. Make all fields of every constructor strict; i.e., add a bang to
        all fields.
     .
     2. Use only strict types for the fields of the constructors. 
     .
     The second requirement is problematic as it rules out the use of
     the standard Haskell 'Maybe', 'Either', and pair types. This library
     solves this problem by providing strict variants of these types and their
     corresponding standard support functions and type-class instances. 
     .
     Note that this library does currently not provide fully strict lists.
     They can be added if they are really required. However, in many cases one
     probably wants to use unboxed or strict boxed vectors from the 'vector'
     library (<http://hackage.haskell.org/package/vector>) instead of strict
     lists.  Moreover, instead of @String@s one probably wants to use strict
     @Text@ values from the @text@ library
     (<http://hackage.haskell.org/package/text>).
     .
     This library comes with batteries included; i.e., missing instances
     for type-classes from the @deepseq@, @binary@, @aeson@, @QuickCheck@, and
     @lens@ packages are included. Of particluar interest is the @Strict@
     type-class provided by the lens library
     (<http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Iso.html#t:Strict>).
     It is used in the following example to simplify the modification of
     strict fields.
     .
     > (-# LANGUAGE TemplateHaskell #-)   -- replace with curly braces, 
     > (-# LANGUAGE OverloadedStrings #-) -- the Haddock prologues are a P.I.T.A!
     > 
     > import           Control.Lens ( (.=), Strict(strict), from, Iso', makeLenses)
     > import           Control.Monad.State.Strict (State)
     > import qualified Data.Map                   as M
     > import qualified Data.Maybe.Strict          as S
     > import qualified Data.Text                  as T
     > 
     > -- | An example of a state record as it could be used in a (very minimal)
     > -- role-playing game.
     > data GameState = GameState
     >     ( _gsCooldown :: !(S.Maybe Int)
     >     , _gsHealth   :: !Int
     >     )  -- replace with curly braces, *grmbl*
     > 
     > makeLenses ''GameState
     > 
     > -- The isomorphism, which converts a strict field to its lazy variant
     > lazy :: Strict lazy strict => Iso' strict lazy
     > lazy = from strict
     > 
     > type Game = State GameState
     > 
     > cast :: T.Text -> Game ()
     > cast spell =
     >     gsCooldown.lazy .= M.lookup spell spellDuration
     >     -- ... implement remainder of spell-casting ...
     >   where
     >     spellDuration = M.fromList [("fireball", 5)]
     .
     See
     <http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html>
     for a gentle introduction to lenses and state manipulation.
     .
     Note that this package uses the types provided by the 'strict' package
     (<http://hackage.haskell.org/package/strict>), but organizes them a bit
     differently. More precisely, the @strict-base-types@ package
     .
     - only provides the fully strict variants of types from 'base',
     .
     - is in-sync with the current base library (base-4.6), 
     .
     - provides the missing instances for (future) Haskell platform packages, and
     .
     - conforms to the standard policy that strictness variants of an existing
       datatype are identified by suffixing \'Strict\' or \'Lazy\' in the
       module hierarchy.


License:        BSD3
License-File:   LICENSE
Author:         Roman Leshchinskiy <rl@cse.unsw.edu.au>,
                Simon Meier <iridcode@gmail.com>
Maintainer:     Simon Meier <iridcode@gmail.com>
Copyright:      (c) 2006-2008 by Roman Leshchinskiy
                (c) 2013-2014 by Simon Meier
Homepage:       https://github.com/meiersi/strict-base-types
Cabal-Version: >= 1.6
Build-type:     Simple

source-repository head
  type:     git
  location: https://github.com/meiersi/strict-base-types.git

library
  build-depends:     
      base       >= 4.5 && < 5
    , lens       >= 3.9
    , QuickCheck >= 2
    , aeson      >= 0.6
    , binary     >= 0.5
    , deepseq    >= 1.3
    , strict     == 0.3.*
    , bifunctors >= 3.0
    , ghc-prim
  hs-source-dirs:    src
  exposed-modules:
      Data.Tuple.Strict
      Data.Maybe.Strict
      Data.Either.Strict
  ghc-options:    -Wall


-- BEGIN Added by all-cabal-hashes-tool
x-package-hashes:
    MD5:c4ef59f8b507ce2a30277def4fd73d47
    SHA1:911173768f57c57dc421e6dd61c2f913b79654ef
    SHA256:5719ddee83f88bc918597ed6be98a9f3a433e8fe7a2083cdffbb2d1b705c14bf
    SHA512:dc65c741fd83ea05ee12b0d47f0e96fc4d409de54151555a8c9bbfcbe7354726ceb022074aa380e3bd4605a32379698af3ea908268c3a5cf516feb5ec2e97487
    Skein512_512:52890aed0ac988158fb9cbe76d1f97eb400dff85ea2ec059f64535f1d3ca3686304cef8df2acd4f332a140ea7de651b1e6f3d52f693f51f42b6cddce230b3743

x-package-locations:
    https://hackage.haskell.org/package/named-records-0.2.2/named-records-0.2.2.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/named-records-0.2.2.tar.gz

x-package-size: 3417
-- END Added by all-cabal-hashes-tool

Name:           named-records
Version:        0.2.2
Synopsis:       Flexible records with named fields.
Description:    Flexible records with named fields.
                .
                [@v0.2@] Default values with @record@.
                .
                [@v0.2.1@] Requires @names-0.2.1@.
                .
                [@v0.2.2@] TH @record@ definitions allow for
                    more types to be used in the definition.
                .
                Named records allow you to define und use records
                with labeled fields. These records are first class
                objects. Record fields are labeled by names, which
                can basically be any type. However, the names package
                provides global name types and some syntactic sugar
                to use them.
                .
                Here is a complete walk-through, with Template Haskell
                syntactic sugar.
                .
                This is how a typical example preamble looks like:
                .
                > {-# LANGUAGE Haskell2010, TemplateHaskell #-}
                > 
                > import qualified Data.Name
                > import Data.NamedRecord
                .
                In order to use names you need to declare them first
                (see the @names@ package for further details):
                .
                > name "firstName"
                > name "lastName"
                .
                These are two records @Person@ and @User@:
                .
                > record "Person"
                >     `has` "firstName" := ''String
                >     `has` "lastName"  := ''String
                >
                > record "User"
                >     `has` "firstName" := ''String
                >     `has` "lastName"  := ''String
                >     `has` "loginName" := ''String
                .
                Note that these declarations create constructor
                functions @newPerson@ and @newUser@, as well as
                type synonyms @Person@ and @User@ (use @-ddump-slices@
                to see what has been generated).
                .
                Here are two instances of these recors:
                . 
                > julian = newPerson
                >    `set` firstName := "Julian"
                >    `set` lastName  := "Fleischer"
                >
                > alexander = newUser
                >    `set` firstName := "Alexander"
                >    `set` lastName  := "Carnicero"
                >    `set` loginName := "alexander.carnicero"
                .
                We can now create a @displayName@ function like
                the following:
                .
                > displayName obj =
                >     (obj `get` firstName) ++ " " ++
                >     (obj `get` lastName)
                .
                Note that this function will accept any record
                that has a @firstName@ and a @lastName@ field of
                type @String@.
                .
                >>> displayName julian
                Julian Fleischer
                .
                >>> displayName alexander
                Alexander Carnicero
                .
                As mentioned above, records are first class citizens.
                That means you can create them anywhere:
                .
                >>> displayName (firstName := "John" :+ lastName := "Doe")
                John Doe               
                
License:        MIT
License-File:   LICENSE
Author:         Julian Fleischer <julian.fleischer@fu-berlin.de>
Maintainer:     Julian Fleischer <julian.fleischer@fu-berlin.de>
Build-Type:     Simple
Cabal-Version:  >= 1.6
Category:       Data, Records
Stability:      experimental

Library
    Exposed-Modules:    Data.NamedRecord

    Build-Depends:      base >= 4 && < 5,
                        names == 0.2.2,
                        template-haskell >= 2.7

    Hs-Source-Dirs:     src



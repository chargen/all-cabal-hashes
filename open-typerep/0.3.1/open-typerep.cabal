-- BEGIN Added by all-cabal-hashes-tool
package-hashes:
    MD5:d0188fb1c77420de0c9e4d953585296d
    SHA1:fee63edc016020a4915ca3b315237f797fb7e557
    SHA256:fa7bb0604e0d8868678fc2d1bf2f66f915e8c1e6d29159c823ade0ef0ecca3f3
    SHA512:cf57224abed3013049f09ef1864368f5c6ed5f7c7d6777477efe472f30f0e0b2cb1acc2983d6a05cf6fb4a94f6dbfb9ff195d6e95ed9665c6978492fd3483159
    Skein512_512:ed949cca9fae7a819b5d18ecc6b56302a51c48fd5da0899f935fa461c2d7207c4f626179ee79c6b56c9032814f3f05d98738f225275da141e19034a2af84070e

package-locations:
    https://hackage.haskell.org/package/open-typerep-0.3.1/open-typerep-0.3.1.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/open-typerep-0.3.1.tar.gz

package-size: 8823
-- END Added by all-cabal-hashes-tool

name:                open-typerep
version:             0.3.1
synopsis:            Open type representations and dynamic types
description:         This package uses Data Types Ã  la Carte to provide open type representations
                     and dynamic types/coercions for open type universes.
                     .
                     Example 1 (dynamic types):
                     .
                     > type MyUniverse = IntType :+: BoolType
                     >
                     > hlist :: [Dynamic MyUniverse]
                     > hlist = [toDyn True, toDyn (1 :: Int)]
                     .
                     > *Main> hlist
                     > [True,1]
                     .
                     Note that if we were using "Data.Dynamic", it would just print
                     .
                     > [<<Bool>>,<<Int>>]
                     .
                     Example 2 (dynamically typed addition):
                     .
                     > addDyn :: (TypeEq ts ts, PWitness Num ts ts) => Dynamic ts -> Dynamic ts -> Maybe (Dynamic ts)
                     > addDyn (Dyn ta a) (Dyn tb b) = do
                     >     Dict <- typeEq ta tb
                     >     Dict <- pwit pNum ta
                     >     return (Dyn ta (a+b))
                     .
                     "Data.Dynamic" could only do this monomorphically, for one 'Num' type at a
                     time.
author:              Emil Axelsson
maintainer:          emax@chalmers.se
copyright:           Copyright (c) 2014, Emil Axelsson
license:             BSD3
license-file:        LICENSE
homepage:            https://github.com/emilaxelsson/open-typerep
bug-reports:         https://github.com/emilaxelsson/open-typerep/issues
category:            Dependent Types
stability:           experimental
build-type:          Simple
cabal-version:       >=1.10

extra-source-files:
  examples/*.hs

source-repository head
  type:     git
  location: https://github.com/emilaxelsson/open-typerep

library
  hs-source-dirs: src

  exposed-modules:
    Data.TypeRep.Internal
    Data.TypeRep
    Data.TypeRep.VarArg

  other-modules:
    Data.TypeRep.Sub

  build-depends:
    base        >=4 && <5,
    constraints >=0.3,
    mtl         >=2.1,
    syntactic   >=2.0,
    tagged      >=0.4

  default-language: Haskell2010

  default-extensions:
    ConstraintKinds
    FlexibleContexts
    FlexibleInstances
    GADTs
    MultiParamTypeClasses
    Rank2Types
    ScopedTypeVariables
    TypeFamilies
    TypeOperators

  other-extensions:
    UndecidableInstances,
    OverlappingInstances

test-suite examples
  type: exitcode-stdio-1.0

  hs-source-dirs: examples

  main-is: Simple.hs

  default-language: Haskell2010

  build-depends:
    open-typerep,
    base

  default-language: Haskell2010

  default-extensions:
    FlexibleContexts
    GADTs
    TypeOperators

benchmark dynamic-bench
  type: exitcode-stdio-1.0

  hs-source-dirs: benchmarks

  main-is: Dynamic.hs

  build-depends:
    base,
    criterion >= 1,
    open-typerep

  default-language: Haskell2010

  default-extensions:
    FlexibleInstances
    GADTs
    MultiParamTypeClasses
    TypeOperators

  other-extensions:
    TemplateHaskell

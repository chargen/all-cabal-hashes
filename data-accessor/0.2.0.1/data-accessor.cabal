-- BEGIN Added by all-cabal-hashes-tool
x-package-hashes:
    MD5:e47603a1a03dbf9eeb939e21e744ead2
    SHA1:554f55fffe1d31548b14a4289255a26d2d8cf13b
    SHA256:bf6db85d78ceea57f4873703cd849f613800bafab10066df583159b6549e7316
    SHA512:95c52d395482506568bb9ebbf205fde6f96b7b9207c1ccbcefdd7f0e6732979131c031e4ceb9e0e47c856a1ca66a0a5e20a09437937173c9a7dad66b56caa8da
    Skein512_512:dccc65c80d50363a23f7686ef501599fe68f2c351d03e618f98f995124518e4103d22bc10b93a9ebf553f62cc21f553071ab60802b0d824859e2b9dee6bf70d7

x-package-locations:
    https://hackage.haskell.org/package/data-accessor-0.2.0.1/data-accessor-0.2.0.1.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/data-accessor-0.2.0.1.tar.gz

x-package-size: 7391
-- END Added by all-cabal-hashes-tool

Name:             data-accessor
Version:          0.2.0.1
License:          BSD3
License-File:     LICENSE
Author:           Henning Thielemann <haskell@henning-thielemann.de>, Luke Palmer <lrpalmer@gmail.com>
Maintainer:       Henning Thielemann <haskell@henning-thielemann.de>
Homepage:         http://www.haskell.org/haskellwiki/Record_access
Package-URL:      http://code.haskell.org/data-accessor/
Category:         Data
-- Portability:      Haskell98, not quite because of MTL dependency
Build-Type:       Simple
Build-Depends:    base>=1.0, array >=0.1 && <1, containers >=0.1 && <1, transformers >=0.0.1 && <0.1
Synopsis:         Utilities for accessing and manipulating fields of records
Description:
  In Haskell 98 the name of a record field
  is automatically also the name of a function which gets the value
  of the according field.
  E.g. if we have
  .
    data Pair a b = Pair {first :: a, second :: b}
  .
  then
  .
  > first  :: Pair a b -> a
  > second :: Pair a b -> b
  .
  However for setting or modifying a field value
  we need to use some syntactic sugar, which is often clumsy.
  .
    modifyFirst :: (a -> a) -> (Pair a b -> Pair a b)
    modifyFirst f r\@(Pair {first=a}) = r{first = f a}
  .
  With this package you can define record field accessors
  which allow setting, getting and modifying values easily.
  The package clearly demonstrates the power of the functional approach:
  You can combine accessors of a record and sub-records,
  to make the access look like the fields of the sub-record belong to the main record.
  .
  Example:
  .
  > *Data.Accessor.Example> (first^:second^=10) (('b',7),"hallo")
  > (('b',10),"hallo")
  .
  You can easily manipulate record fields in a 'Control.Monad.State.State' monad,
  you can easily code Show instances that use the Accessor syntax
  and you can parse binary streams into records.
  See @Data.Accessor.Example@ for demonstration of all features.
  .
  It would be great if in revised Haskell versions the names of record fields
  are automatically 'Data.Accessor.Accessor's
  rather than plain @get@ functions.
  The package @data-accessor-template@ provides Template Haskell functions
  for automated generation of 'Data.Acesssor.Accessor's.
GHC-Options:      -Wall
Tested-With:      GHC==6.4.1 && ==6.8.2
Hs-Source-Dirs:   src
Exposed-Modules:
  Data.Accessor
  Data.Accessor.Basic
  Data.Accessor.Container
  Data.Accessor.Show
  Data.Accessor.Tuple
  Data.Accessor.BinaryRead
  Data.Accessor.MonadState
Other-Modules:
  Data.Accessor.Example

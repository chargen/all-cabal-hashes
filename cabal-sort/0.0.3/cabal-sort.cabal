Name:             cabal-sort
Version:          0.0.3
License:          BSD3
License-File:     LICENSE
Author:           Henning Thielemann <haskell@henning-thielemann.de>
Maintainer:       Henning Thielemann <haskell@henning-thielemann.de>
-- Homepage:         http://www.haskell.org/haskellwiki/Cabal
Category:         Distribution
Synopsis:         Topologically sort cabal packages
Description:
  If you have a bunch of packages you may want to compile or recompile,
  then you need an order of compilation that meets the dependencies.
  Given a number of cabal package files,
  this program reads all those files
  and emits them topologically sorted according to their dependencies.
  This way you can compile many packages at once,
  say if a very low-level package has changed.
  .
  For compiling a couple of packages from their local darcs repositories
  in the right order, you may run something like
  .
  > for dir in `find . -name "*.cabal" | fgrep -v _darcs | xargs cabal-sort --info=dir`; do (cd $dir && cabal install); done
  .
  For uploading a set of packages to Hackage in the right order
  you may run
  .
  > for dir in `find . -name "*.cabal" | fgrep -v _darcs | xargs cabal-sort --info=dir`; do (cd $dir && rm dist/*.tar.gz && cabal sdist && cabal upload dist/*.tar.gz); done
  .
  Problem 1: Given packages A, B, C,
  where C depends on B and B depends on A,
  and you call
  .
  > cabal-sort C.cabal A.cabal
  .
  then the emitted order of packages may be wrong,
  because cabal-sort does not get to know the dependency of C on B.
  Even if the order is correct,
  B.cabal is missing in the output
  and thus the list of cabal files cannot immediately be used
  for a sequence of cabal-install runs.
  .
  Problem 2: We ignore flags and merge all dependencies.
  This may lead to dependency cycles that cannot occur for any flag assignment.
  .
  There is a second program called @ghc-pkg-dep@
  that finds recursively all packages that a set of packages depends on.
  Duplicates are eliminated and the packages are given topologically sorted,
  such that you can use this for recompilation of the packages.
  .
  > ghc-pkg-dep pkgA-0.1 pkgB-2.3 pkgC-0.1.2
  .
  Unfortunately ghc-pkg runs quite slowly.
  In order to not get bored you may run the program with @--verbose=2@ option.
  Maybe there is a way to query the complete GHC package database at once.
Tested-With:       GHC==6.10.4
Cabal-Version:     >=1.6
Build-Type:        Simple
Source-Repository head
  type:     darcs
  location: http://code.haskell.org/~thielema/cabal-sort/

Source-Repository this
  type:     darcs
  location: http://code.haskell.org/~thielema/cabal-sort/
  tag:      0.0.3


Executable cabal-sort
  Build-Depends:
    Cabal >=1.6 && <1.11,
    fgl >=5.4.2 && <5.5,
    directory >=1 && <1.2,
    filepath >=1.1 && <1.3,
    containers >=0.2 && <0.5,
    explicit-exception >=0.1.4 && <0.2,
    transformers >=0.2 && <0.3,
    base >=2 && <5

  GHC-Options:      -Wall
  Hs-source-dirs:   src
  Main-Is:          CabalSort.hs

Executable ghc-pkg-dep
  Build-Depends:
    Cabal >=1.6 && <1.11,
    process >=1.0 && <1.1,
    containers >=0.2 && <0.5,
    explicit-exception >=0.1.6 && <0.2,
    utility-ht >=0.0.5 && <0.1,
    transformers >=0.2 && <0.3,
    bytestring >=0.9.1 && <0.10,
    base >=2 && <5

  GHC-Options:      -Wall
  Hs-source-dirs:   src
  Main-Is:          GhcPkgDep.hs


package-hashes:
    MD5:b6abe5e10c479fc5d1b2de6e6cd92196
    SHA1:b48f86109d7bc17b36a0c318617557d0a33ab6c7
    SHA256:b2a0c071b5f4d0e5c4d34c1365f8b71e09b19ba34622fe5195efdc937c94c7a7
    SHA512:3e77f82b03afd66624ee3e73c086823a185394b9d38faaf6d955dc886d6c758c19a966a2125b8aa8d2eab669eb4a434e41cf4f4c4dc54952f5a8bc37bd1b8505
    Skein512_512:4cd7d7c59de6e842d8dd6ac9912773bb706b31ddd1113bda3c58b2a9d982c92ed4d7c50b21d4277463dfeecfaed3a5d3488494c8df51904a9842eb9a5cbb6e94

package-locations:
    https://hackage.haskell.org/package/cabal-sort-0.0.3/cabal-sort-0.0.3.tar.gz
    https://s3.amazonaws.com/hackage.fpcomplete.com/package/cabal-sort-0.0.3.tar.gz

package-size: 5818
